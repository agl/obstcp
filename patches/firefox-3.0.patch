diff --git a/netwerk/base/src/Makefile.in b/netwerk/base/src/Makefile.in
index 4c2dea5..1238a03 100644
--- a/netwerk/base/src/Makefile.in
+++ b/netwerk/base/src/Makefile.in
@@ -95,6 +95,8 @@ CPPSRCS		= \
 		nsSerializationHelper.cpp \
 		$(NULL)
 
+LIBS += -lobstcp
+
 ifeq ($(MOZ_WIDGET_TOOLKIT),os2)
 	CPPSRCS += nsURLHelperOS2.cpp
 else
diff --git a/netwerk/base/src/nsSocketTransport2.cpp b/netwerk/base/src/nsSocketTransport2.cpp
index e81a367..18b995e 100644
--- a/netwerk/base/src/nsSocketTransport2.cpp
+++ b/netwerk/base/src/nsSocketTransport2.cpp
@@ -48,6 +48,8 @@
 #include "nsNetSegmentUtils.h"
 #include "nsTransportUtils.h"
 #include "nsProxyInfo.h"
+#include "nsIPrefService.h"
+#include "nsIPrefBranch2.h"
 #include "nsNetCID.h"
 #include "nsAutoLock.h"
 #include "nsAutoPtr.h"
@@ -59,7 +61,9 @@
 #include "plstr.h"
 #include "prnetdb.h"
 #include "prerror.h"
+#include "prrng.h"
 #include "prerr.h"
+#include "prlock.h"
 
 #include "nsIServiceManager.h"
 #include "nsIProxyObjectManager.h"
@@ -75,6 +79,10 @@
 #include "nsNativeConnectionHelper.h"
 #endif
 
+#include <unistd.h>
+
+#include <libobstcp.h>
+
 //-----------------------------------------------------------------------------
 
 static NS_DEFINE_CID(kSocketProviderServiceCID, NS_SOCKETPROVIDERSERVICE_CID);
@@ -82,6 +90,26 @@ static NS_DEFINE_CID(kDNSServiceCID, NS_DNSSERVICE_CID);
 
 //-----------------------------------------------------------------------------
 
+// -----------------------------------------------------------------------------
+// Get the per-process keys structure. Not thread safe. Dodgy as hell.
+// -----------------------------------------------------------------------------
+static struct obstcp_keys *
+ns_obstcp_get_keys() {
+    static struct obstcp_keys keys;
+    static char keys_init = 0;
+
+    if (!keys_init) {
+        PRUint8 secret[32];
+        PR_GetRandomNoise(secret, sizeof(secret));
+
+        obstcp_keys_init(&keys);
+        obstcp_keys_key_add(&keys, secret);
+        keys_init = 1;
+    }
+
+    return &keys;
+}
+
 class nsSocketEvent : public nsRunnable
 {
 public:
@@ -326,6 +354,13 @@ nsSocketInputStream::Available(PRUint32 *avail)
     return rv;
 }
 
+static ssize_t
+ReadWrapper(void *ptr, PRUint8 *buffer, size_t len) {
+    PRFileDesc *fd = (PRFileDesc *) ptr;
+
+    return PR_Read(fd, buffer, len);
+}
+
 NS_IMETHODIMP
 nsSocketInputStream::Read(char *buf, PRUint32 count, PRUint32 *countRead)
 {
@@ -350,7 +385,14 @@ nsSocketInputStream::Read(char *buf, PRUint32 count, PRUint32 *countRead)
     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
     // synchronously proxies notifications over to the UI thread, which could
     // mistakenly try to re-enter this code.)
-    PRInt32 n = PR_Read(fd, buf, count);
+    PRInt32 n;
+
+    if (mTransport->mObfuscation) {
+        n = obstcp_rbuf_read(&mTransport->mObsRBuf, (PRUint8 *) buf, count,
+                             ReadWrapper, fd);
+    } else {
+        n = PR_Read(fd, buf, count);
+    }
 
     LOG(("  PR_Read returned [n=%d]\n", n));
 
@@ -469,17 +511,56 @@ nsSocketInputStream::AsyncWait(nsIInputStreamCallback *callback,
 // socket output stream impl 
 //-----------------------------------------------------------------------------
 
+struct chunk {
+  struct chunk *next, *last;
+  unsigned length, done;
+  PRUint8 data[1];
+};
+
+static void
+chunk_nq(struct chunk *c, struct chunk **head, struct chunk **tail) {
+  c->last = *tail;
+  c->next = NULL;
+  *tail = c;
+  if (!*head) *head = c;
+}
+
+static void
+chunk_free(struct chunk **head, struct chunk **tail) {
+  if ((*head)->next)
+    (*head)->next->last = NULL;
+
+  struct chunk *next = (*head)->next;
+  free(*head);
+
+  if (*tail == *head) *tail = NULL;
+  *head = next;
+}
+
+static void
+chunks_free(struct chunk *head) {
+    struct chunk *next;
+
+    for (; head; head = next) {
+        next = head->next;
+        free(head);
+    }
+}
+
 nsSocketOutputStream::nsSocketOutputStream(nsSocketTransport *trans)
     : mTransport(trans)
     , mWriterRefCnt(0)
     , mCondition(NS_OK)
     , mCallbackFlags(0)
     , mByteCount(0)
+    , mChunkHead(0)
+    , mChunkTail(0)
 {
 }
 
 nsSocketOutputStream::~nsSocketOutputStream()
 {
+    chunks_free(mChunkHead);
 }
 
 // called on the socket transport thread...
@@ -553,6 +634,10 @@ nsSocketOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *countWrit
 
     *countWritten = 0;
 
+    static const unsigned kNumIOV = 16;
+    PRIOVec iov[16];
+    unsigned numiov;
+
     if (count == 0)
         return NS_OK;
 
@@ -566,6 +651,47 @@ nsSocketOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *countWrit
         fd = mTransport->GetFD_Locked();
         if (!fd)
             return NS_BASE_STREAM_WOULD_BLOCK;
+
+        if (mTransport->mObfuscation) {
+            size_t pending = 0;
+            struct iovec iniov[kNumIOV], outiov[kNumIOV];
+            unsigned j = 0;  // indexes @iniov
+
+            for (struct chunk *c = mChunkHead; c; c = c->next) {
+                pending += c->length - c->done;
+                if (j < kNumIOV) {
+                    iniov[j].iov_base = c->data + c->done;
+                    iniov[j++].iov_len = c->length - c->done;
+                }
+            }
+
+            const size_t toEnqueue = count > pending ? count - pending : 0;
+            if (toEnqueue) {
+                struct chunk *c = (struct chunk *) malloc(sizeof(struct chunk) + toEnqueue);
+                memset(c, 0, sizeof(struct chunk));
+                c->length = toEnqueue;
+                memcpy(c->data, buf + pending, toEnqueue);
+                chunk_nq(c, &mChunkHead, &mChunkTail);
+                if (j < kNumIOV) {
+                    iniov[j].iov_base = c->data;
+                    iniov[j++].iov_len = c->length;
+                }
+            }
+
+            unsigned numout = kNumIOV;
+            obstcp_accum_prepare(&mTransport->mObsAccum, outiov, &numout,
+                                 iniov, j);
+            // copy from the real iovecs to PR's iovecs
+            for (unsigned i = 0; i < numout; ++i) {
+                iov[i].iov_base = (char *) outiov[i].iov_base;
+                iov[i].iov_len = outiov[i].iov_len;
+            }
+            numiov = numout;
+        } else {
+            numiov = 1;
+            iov[0].iov_base = (char *) buf;
+            iov[0].iov_len = count;
+        }
     }
 
     LOG(("  calling PR_Write [count=%u]\n", count));
@@ -573,7 +699,14 @@ nsSocketOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *countWrit
     // cannot hold lock while calling NSPR.  (worried about the fact that PSM
     // synchronously proxies notifications over to the UI thread, which could
     // mistakenly try to re-enter this code.)
-    PRInt32 n = PR_Write(fd, buf, count);
+
+    PRInt32 n;
+
+    if (numiov == 1) {
+        n = PR_Write(fd, iov[0].iov_base, iov[0].iov_len);
+    } else if (numiov > 1) {
+        n = PR_Writev(fd, iov, numiov, 0);
+    }
 
     LOG(("  PR_Write returned [n=%d]\n", n));
     NS_ASSERTION(n != 0, "unexpected return value");
@@ -583,15 +716,28 @@ nsSocketOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *countWrit
         nsAutoLock lock(mTransport->mLock);
 
 #ifdef ENABLE_SOCKET_TRACING
-    if (n > 0)
-        mTransport->TraceOutBuf(buf, n);
+        if (n > 0) mTransport->TraceOutBuf(buf, n);
 #endif
 
         mTransport->ReleaseFD_Locked(fd);
 
-        if (n > 0)
-            mByteCount += (*countWritten = n);
-        else if (n < 0) {
+        if (n > 0) {
+            *countWritten = n;
+            mByteCount += n;
+            if (mTransport->mObfuscation) {
+                const ssize_t bytes_written = obstcp_accum_commit(&mTransport->mObsAccum, n);
+
+                struct chunk *next;
+                for (struct chunk *c = mChunkHead; c; c = next) {
+                    next = c->next;
+                    const ssize_t todo = c->length - c->done;
+                    ssize_t done = bytes_written;
+                    if (done > todo) done = todo;
+                    c->done += done;
+                    if (c->done == c->length) chunk_free(&mChunkHead, &mChunkTail);
+                }
+            }
+        } else if (n < 0) {
             PRErrorCode code = PR_GetError();
             if (code == PR_WOULD_BLOCK_ERROR)
                 return NS_BASE_STREAM_WOULD_BLOCK;
@@ -712,6 +858,7 @@ nsSocketTransport::nsSocketTransport()
     , mInputClosed(PR_TRUE)
     , mOutputClosed(PR_TRUE)
     , mResolving(PR_FALSE)
+    , mObfuscation(0)
     , mLock(PR_NewLock())
     , mFD(nsnull)
     , mFDref(0)
@@ -730,6 +877,8 @@ nsSocketTransport::nsSocketTransport()
 nsSocketTransport::~nsSocketTransport()
 {
     LOG(("destroying nsSocketTransport @%x\n", this));
+    if (mObfuscation)
+        obstcp_rbuf_free(&mObsRBuf);
 
     // cleanup socket type info
     if (mTypes) {
@@ -741,7 +890,7 @@ nsSocketTransport::~nsSocketTransport()
 
     if (mLock)
         PR_DestroyLock(mLock);
- 
+
     nsSocketTransportService *serv = gSocketTransportService;
     NS_RELEASE(serv); // nulls argument
 }
@@ -1155,11 +1304,49 @@ nsSocketTransport::InitiateSocket()
     // 
     // Initiate the connect() to the host...  
     //
+    struct obstcp_keys *const keys = ns_obstcp_get_keys();
+    nsXPIDLCString tempString;
+
+    nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+    if (mProxyPort == 0 && strlen(mHost.get()) && mPort == 80) {
+        char buffer[512];
+        snprintf(buffer, 512, "network.obstcp.%s", mHost.get());
+
+        nsresult prefsrv =
+            prefs->GetCharPref(buffer, getter_Copies(tempString));
+        if (NS_SUCCEEDED(prefsrv)) {
+            const char msg[] = "OBSTCP:switching\n";
+            write(1, msg, strlen(msg));
+            int newport;
+
+            if (obstcp_advert_parse(tempString.get(), strlen(tempString.get()),
+                                    OBSTCP_ADVERT_OBSPORT, &newport,
+                                    OBSTCP_ADVERT_END) &&
+                newport) {
+                mNetAddr.inet.port = htons(newport);
+                mObfuscation = 1;
+                PRUint8 random[16];
+                PR_GetRandomNoise(random, sizeof(random));
+                if (!obstcp_client_ctx_init(&mObsContext, keys, tempString.get(),
+                                            strlen(tempString.get()), random)) {
+                    abort();
+                }
+                obstcp_client_accum_init(&mObsAccum, &mObsContext);
+                obstcp_rbuf_client_init(&mObsRBuf, &mObsContext);
+            }
+        }
+    }
+
     status = PR_Connect(fd, &mNetAddr, NS_SOCKET_CONNECT_TIMEOUT);
     if (status == PR_SUCCESS) {
         // 
         // we are connected!
         //
+        if (mObfuscation) {
+            struct iovec iov;
+            obstcp_client_banner(&mObsContext, &iov);
+            PR_Write(fd, iov.iov_base, iov.iov_len);
+        }
         OnSocketConnected();
     }
     else {
@@ -1179,6 +1366,11 @@ nsSocketTransport::InitiateSocket()
             //
             // we are connected!
             //
+            if (mObfuscation) {
+                struct iovec iov;
+                obstcp_client_banner(&mObsContext, &iov);
+                PR_Write(fd, iov.iov_base, iov.iov_len);
+            }
             OnSocketConnected();
 
             if (mSecInfo && !mProxyHost.IsEmpty() && proxyTransparent && usingSSL) {
@@ -1506,6 +1698,11 @@ nsSocketTransport::OnSocketReady(PRFileDesc *fd, PRInt16 outFlags)
             //
             // we are connected!
             //
+            if (mObfuscation) {
+                struct iovec iov;
+                obstcp_client_banner(&mObsContext, &iov);
+                PR_Write(fd, iov.iov_base, iov.iov_len);
+            }
             OnSocketConnected();
         }
         else {
diff --git a/netwerk/base/src/nsSocketTransport2.h b/netwerk/base/src/nsSocketTransport2.h
index de4133f..3b2c177 100644
--- a/netwerk/base/src/nsSocketTransport2.h
+++ b/netwerk/base/src/nsSocketTransport2.h
@@ -56,6 +56,8 @@
 #include "nsICancelable.h"
 #include "nsIClassInfo.h"
 
+#include <libobstcp.h>
+
 class nsSocketTransport;
 
 //-----------------------------------------------------------------------------
@@ -95,6 +97,8 @@ private:
 
 //-----------------------------------------------------------------------------
 
+struct chunk;
+
 class nsSocketOutputStream : public nsIAsyncOutputStream
 {
 public:
@@ -125,6 +129,8 @@ private:
     nsCOMPtr<nsIOutputStreamCallback> mCallback;
     PRUint32                          mCallbackFlags;
     nsUint64                          mByteCount;
+    struct chunk                      *mChunkHead;
+    struct chunk                      *mChunkTail;
 };
 
 //-----------------------------------------------------------------------------
@@ -224,6 +230,10 @@ private:
     nsCOMPtr<nsICancelable> mDNSRequest;
     nsCOMPtr<nsIDNSRecord>  mDNSRecord;
     PRNetAddr               mNetAddr;
+    bool                    mObfuscation;
+    struct obstcp_client_ctx mObsContext;
+    struct obstcp_rbuf      mObsRBuf;
+    struct obstcp_accum     mObsAccum;
 
     // socket methods (these can only be called on the socket thread):
 
diff --git a/netwerk/dns/public/nsIDNSRecord.idl b/netwerk/dns/public/nsIDNSRecord.idl
index 4e6d68f..71b7b1f 100644
--- a/netwerk/dns/public/nsIDNSRecord.idl
+++ b/netwerk/dns/public/nsIDNSRecord.idl
@@ -58,6 +58,12 @@ interface nsIDNSRecord : nsISupports
     readonly attribute ACString canonicalName;
 
     /**
+     * @returns the (binary) ObsTCP advert.
+     * @throws NS_ERROR_NOT_AVAILABLE if no advert was found
+     */
+    readonly attribute ACString advert;
+
+    /**
      * this function copies the value of the next IP address into the
      * given PRNetAddr struct and increments the internal address iterator.
      *
diff --git a/netwerk/dns/src/nsDNSService2.cpp b/netwerk/dns/src/nsDNSService2.cpp
index a6b8a75..335bf7a 100644
--- a/netwerk/dns/src/nsDNSService2.cpp
+++ b/netwerk/dns/src/nsDNSService2.cpp
@@ -64,6 +64,55 @@ static const char kPrefDisableIPv6[]        = "network.dns.disableIPv6";
 
 //-----------------------------------------------------------------------------
 
+typedef unsigned char uint8_t;
+
+static const uint8_t kValues[] = {
+99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,0,1,2,3,4,5,6,7,8,9,99,99,99,99,99,99,99,99,10,11,12,99,13,14,15,99,16,17,18,19,20,99,21,22,23,24,25,26,27,28,29,30,31,99,99,99,99,99,99,99,10,11,12,99,13,14,15,99,16,17,18,19,20,99,21,22,23,24,25,26,27,28,29,30,31,99,99,99,99,99};
+
+int
+base32_decode(uint8_t *output, unsigned *ooutlen,
+              const uint8_t *in, unsigned inlen, int mode) {
+  unsigned i = 0, j = 0;
+  unsigned v = 0, bits = 0;
+  const unsigned outlen = *ooutlen;
+
+  while (j < inlen) {
+    if (in[j] & 0x80)
+      goto PROTO;
+    const uint8_t b = kValues[in[j++]];
+    if (b > 31)
+      goto PROTO;
+
+    v |= ((unsigned) b) << bits;
+    bits += 5;
+
+    if (bits >= 8) {
+      if (i >= outlen)
+        goto TOOBIG;
+      output[i++] = v;
+      bits -= 8;
+      v >>= 8;
+    }
+  }
+
+  if (mode) {
+    if (bits && i >= outlen)
+      goto TOOBIG;
+    output[i++] = v & ((1 << bits) - 1);
+  }
+
+  *ooutlen = i;
+  return 1;
+
+ TOOBIG:
+  return 0;
+
+ PROTO:
+  return 0;
+}
+
+//-----------------------------------------------------------------------------
+
 class nsDNSRecord : public nsIDNSRecord
 {
 public:
@@ -72,16 +121,16 @@ public:
 
     nsDNSRecord(nsHostRecord *hostRecord)
         : mHostRecord(hostRecord)
-        , mIter(nsnull)
-        , mIterGenCnt(-1)
+        , mIter(-1)
+        , mIterGenCnt(0)
         , mDone(PR_FALSE) {}
 
 private:
     virtual ~nsDNSRecord() {}
 
     nsRefPtr<nsHostRecord>  mHostRecord;
-    void                   *mIter;
-    int                     mIterGenCnt; // the generation count of
+    int                     mIter;
+    unsigned                mIterGenCnt; // the generation count of
                                          // mHostRecord->addr_info when we
                                          // start iterating
     PRBool                  mDone;
@@ -99,16 +148,80 @@ nsDNSRecord::GetCanonicalName(nsACString &result)
     // if the record is for an IP address literal, then the canonical
     // host name is the IP address literal.
     const char *cname;
-    PR_Lock(mHostRecord->addr_info_lock);
-    if (mHostRecord->addr_info)
-        cname = PR_GetCanonNameFromAddrInfo(mHostRecord->addr_info);
+    PR_Lock(mHostRecord->hostent_lock);
+    if (mHostRecord->hostent_buf)
+        cname = mHostRecord->hostent.h_name;
     else
         cname = mHostRecord->host;
     result.Assign(cname);
-    PR_Unlock(mHostRecord->addr_info_lock);
+    PR_Unlock(mHostRecord->hostent_lock);
     return NS_OK;
 }
 
+static int
+advertInName(nsACString &result, const char *name) {
+    // A hostname can only be 256 bytes long, so this buffer is long enough to
+    // hold and any valid advert encoded in a name.
+    unsigned char t[256];
+    unsigned j = 0;  // current offset into t
+
+    for (;;) {
+        if (strncmp(name, "opa", 3) == 0) {
+            bool good = true;
+            unsigned count = 0;
+
+            for (const char *i = name + 3; *i; ++i, count++) {
+                const char c = *i;
+                if ((c >= '0' && c <= '9') ||
+                    (c > 'a' && c <= 'z' && c != 'e' && c != 'i' && c != 'o') ||
+                    (c > 'A' && c <= 'Z' && c != 'E' && c != 'I' && c != 'O'))
+                    continue;
+                good = false;
+                break;
+            }
+
+            if (count == 0 || (count * 5) & 7)
+                good = false;
+
+            unsigned space = sizeof(t) - j;
+            if (!base32_decode(t + j, &space, (const uint8_t *) name + 3, count, 1))
+                return 0;
+            j += space;
+        }
+    }
+
+    if (!j)
+        return 0;
+
+    result.Assign((const char *) t, j);
+    return 1;
+}
+
+NS_IMETHODIMP
+nsDNSRecord::GetAdvert(nsACString &result)
+{
+    PR_Lock(mHostRecord->hostent_lock);
+    if (!mHostRecord->hostent_buf) {
+        PR_Unlock(mHostRecord->hostent_lock);
+        return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    for (unsigned i = 0; mHostRecord->hostent.h_aliases[i]; ++i) {
+        if (advertInName(result, mHostRecord->hostent.h_aliases[i])) {
+            PR_Unlock(mHostRecord->hostent_lock);
+            return NS_OK;
+        }
+    }
+
+    if (advertInName(result, mHostRecord->hostent.h_name)) {
+        PR_Unlock(mHostRecord->hostent_lock);
+        return NS_OK;
+    }
+
+    PR_Unlock(mHostRecord->hostent_lock);
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 NS_IMETHODIMP
 nsDNSRecord::GetNextAddr(PRUint16 port, PRNetAddr *addr)
 {
@@ -118,25 +231,31 @@ nsDNSRecord::GetNextAddr(PRUint16 port, PRNetAddr *addr)
     if (mDone)
         return NS_ERROR_NOT_AVAILABLE;
 
-    PR_Lock(mHostRecord->addr_info_lock);
-    if (mHostRecord->addr_info) {
-        if (!mIter)
-            mIterGenCnt = mHostRecord->addr_info_gencnt;
-        else if (mIterGenCnt != mHostRecord->addr_info_gencnt) {
+    PR_Lock(mHostRecord->hostent_lock);
+    if (mHostRecord->hostent_buf) {
+        if (mIter == -1) {
+            mIterGenCnt = mHostRecord->hostent_gencnt;
+            mIter = 0;
+        } else if (mIterGenCnt != mHostRecord->hostent_gencnt) {
             // mHostRecord->addr_info has changed, so mIter is invalid.
             // Restart the iteration.  Alternatively, we could just fail.
-            mIter = nsnull;
-            mIterGenCnt = mHostRecord->addr_info_gencnt;
+            mIter = 0;
+            mIterGenCnt = mHostRecord->hostent_gencnt;
         }
-        mIter = PR_EnumerateAddrInfo(mIter, mHostRecord->addr_info, port, addr);
-        PR_Unlock(mHostRecord->addr_info_lock);
-        if (!mIter) {
+        if (mHostRecord->hostent.h_addr_list[mIter] == NULL) {
             mDone = PR_TRUE;
+            PR_Unlock(mHostRecord->hostent_lock);
             return NS_ERROR_NOT_AVAILABLE;
+        } else {
+            addr->raw.family = PR_AF_INET;
+            addr->inet.port = port;
+            memcpy(&addr->inet.ip, mHostRecord->hostent.h_addr_list[mIter++], 4);
+            PR_Unlock(mHostRecord->hostent_lock);
+            return NS_OK;
         }
     }
     else {
-        PR_Unlock(mHostRecord->addr_info_lock);
+        PR_Unlock(mHostRecord->hostent_lock);
         if (!mHostRecord->addr) {
             // Both mHostRecord->addr_info and mHostRecord->addr are null.
             // This can happen if mHostRecord->addr_info expired and the
@@ -152,8 +271,8 @@ nsDNSRecord::GetNextAddr(PRUint16 port, PRNetAddr *addr)
             addr->ipv6.port = port;
         mDone = PR_TRUE; // no iterations
     }
-        
-    return NS_OK; 
+
+    return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -178,13 +297,9 @@ nsDNSRecord::HasMore(PRBool *result)
     if (mDone)
         *result = PR_FALSE;
     else {
-        // unfortunately, NSPR does not provide a way for us to determine if
-        // there is another address other than to simply get the next address.
-        void *iterCopy = mIter;
-        PRNetAddr addr;
-        *result = NS_SUCCEEDED(GetNextAddr(0, &addr));
-        mIter = iterCopy; // backup iterator
-        mDone = PR_FALSE;
+        PR_Lock(mHostRecord->hostent_lock);
+        *result = !mHostRecord->hostent.h_addr_list[mIter];
+        PR_Unlock(mHostRecord->hostent_lock);
     }
     return NS_OK;
 }
@@ -192,8 +307,8 @@ nsDNSRecord::HasMore(PRBool *result)
 NS_IMETHODIMP
 nsDNSRecord::Rewind()
 {
-    mIter = nsnull;
-    mIterGenCnt = -1;
+    mIter = -1;
+    mIterGenCnt = 0;
     mDone = PR_FALSE;
     return NS_OK;
 }
diff --git a/netwerk/dns/src/nsHostResolver.cpp b/netwerk/dns/src/nsHostResolver.cpp
index 924159e..8dd5083 100644
--- a/netwerk/dns/src/nsHostResolver.cpp
+++ b/netwerk/dns/src/nsHostResolver.cpp
@@ -178,9 +178,9 @@ nsHostRecord::Create(const nsHostKey *key, nsHostRecord **result)
 
     rec->_refc = 1; // addref
     NS_LOG_ADDREF(rec, 1, "nsHostRecord", sizeof(nsHostRecord));
-    rec->addr_info_lock = lock;
-    rec->addr_info = nsnull;
-    rec->addr_info_gencnt = 0;
+    rec->hostent_lock = lock;
+    rec->hostent_buf = nsnull;
+    rec->hostent_gencnt = 0;
     rec->addr = nsnull;
     rec->expiration = NowInMinutes();
     rec->resolving = PR_FALSE;
@@ -194,12 +194,12 @@ nsHostRecord::Create(const nsHostKey *key, nsHostRecord **result)
 
 nsHostRecord::~nsHostRecord()
 {
-    if (addr_info_lock)
-        PR_DestroyLock(addr_info_lock);
-    if (addr_info)
-        PR_FreeAddrInfo(addr_info);
+    if (hostent_lock)
+        PR_DestroyLock(hostent_lock);
     if (addr)
         free(addr);
+    if (hostent_buf)
+        free(hostent_buf);
 }
 
 //----------------------------------------------------------------------------
@@ -244,27 +244,6 @@ HostDB_ClearEntry(PLDHashTable *table,
 {
     LOG(("evicting record\n"));
     nsHostDBEnt *he = static_cast<nsHostDBEnt *>(entry);
-#if defined(DEBUG) && defined(PR_LOGGING)
-    if (!he->rec->addr_info)
-        LOG(("%s: => no addr_info\n", he->rec->host));
-    else {
-        PRInt32 now = (PRInt32) NowInMinutes();
-        PRInt32 diff = (PRInt32) he->rec->expiration - now;
-        LOG(("%s: exp=%d => %s\n",
-            he->rec->host, diff,
-            PR_GetCanonNameFromAddrInfo(he->rec->addr_info)));
-        void *iter = nsnull;
-        PRNetAddr addr;
-        char buf[64];
-        for (;;) {
-            iter = PR_EnumerateAddrInfo(iter, he->rec->addr_info, 0, &addr);
-            if (!iter)
-                break;
-            PR_NetAddrToString(&addr, buf, sizeof(buf));
-            LOG(("  %s\n", buf));
-        }
-    }
-#endif
     NS_RELEASE(he->rec);
 }
 
@@ -389,7 +368,7 @@ nsHostResolver::Shutdown()
         while (node != &pendingQ) {
             nsHostRecord *rec = static_cast<nsHostRecord *>(node);
             node = node->next;
-            OnLookupComplete(rec, NS_ERROR_ABORT, nsnull);
+            OnLookupComplete(rec, NS_ERROR_ABORT);
         }
     }
 
@@ -615,7 +594,7 @@ nsHostResolver::GetHostToLookup(nsHostRecord **result)
 }
 
 void
-nsHostResolver::OnLookupComplete(nsHostRecord *rec, nsresult status, PRAddrInfo *result)
+nsHostResolver::OnLookupComplete(nsHostRecord *rec, nsresult status)
 {
     // get the list of pending callbacks for this lookup, and notify
     // them that the lookup is complete.
@@ -627,22 +606,12 @@ nsHostResolver::OnLookupComplete(nsHostRecord *rec, nsresult status, PRAddrInfo
         // grab list of callbacks to notify
         MoveCList(rec->callbacks, cbs);
 
-        // update record fields.  We might have a rec->addr_info already if a
-        // previous lookup result expired and we're reresolving it..
-        PRAddrInfo  *old_addr_info;
-        PR_Lock(rec->addr_info_lock);
-        old_addr_info = rec->addr_info;
-        rec->addr_info = result;
-        rec->addr_info_gencnt++;
-        PR_Unlock(rec->addr_info_lock);
-        if (old_addr_info)
-            PR_FreeAddrInfo(old_addr_info);
         rec->expiration = NowInMinutes();
-        if (result)
+        if (rec->hostent_buf)
             rec->expiration += mMaxCacheLifetime;
         rec->resolving = PR_FALSE;
-        
-        if (rec->addr_info && !mShutdown) {
+
+        if (rec->hostent_buf && !mShutdown) {
             // add to mEvictionQ
             PR_APPEND_LINK(rec, &mEvictionQ);
             NS_ADDREF(rec);
@@ -686,23 +655,26 @@ nsHostResolver::ThreadFunc(void *arg)
 
     nsHostResolver *resolver = (nsHostResolver *) arg;
     nsHostRecord *rec;
-    PRAddrInfo *ai;
     while (resolver->GetHostToLookup(&rec)) {
         LOG(("resolving %s ...\n", rec->host));
 
-        PRIntn flags = PR_AI_ADDRCONFIG;
-        if (!(rec->flags & RES_CANON_NAME))
-            flags |= PR_AI_NOCANONNAME;
-
-        ai = PR_GetAddrInfoByName(rec->host, rec->af, flags);
-#if defined(RES_RETRY_ON_FAILURE)
-        if (!ai && rs.Reset())
-            ai = PR_GetAddrInfoByName(rec->host, rec->af, flags);
-#endif
+        PR_Lock(rec->hostent_lock);
+        if (!rec->hostent_buf)
+            rec->hostent_buf = (char *) malloc(PR_NETDB_BUF_SIZE);
+        if (!rec->hostent_buf)
+            resolver->OnLookupComplete(rec, NS_ERROR_UNKNOWN_HOST);
+
+        nsresult s;
+        s = PR_GetHostByName(rec->host, rec->hostent_buf, PR_NETDB_BUF_SIZE,
+                             &rec->hostent);
+        rec->hostent_gencnt++;
+        if (!NS_SUCCEEDED(s)) {
+            free(rec->hostent_buf);
+            rec->hostent_buf = NULL;
+        }
+        PR_Unlock(rec->hostent_lock);
 
-        // convert error code to nsresult.
-        nsresult status = ai ? NS_OK : NS_ERROR_UNKNOWN_HOST;
-        resolver->OnLookupComplete(rec, status, ai);
+        resolver->OnLookupComplete(rec, s);
         LOG(("lookup complete for %s ...\n", rec->host));
     }
     NS_RELEASE(resolver);
diff --git a/netwerk/dns/src/nsHostResolver.h b/netwerk/dns/src/nsHostResolver.h
index 366ef00..fb6e76f 100644
--- a/netwerk/dns/src/nsHostResolver.h
+++ b/netwerk/dns/src/nsHostResolver.h
@@ -103,13 +103,14 @@ public:
      * the other threads just read it.  therefore the resolver worker
      * thread doesn't need to lock when reading |addr_info|.
      */
-    PRLock      *addr_info_lock;
-    PRAddrInfo  *addr_info;
-    int          addr_info_gencnt; /* generation count of |addr_info| */
+    PRLock      *hostent_lock;
+    PRHostEnt    hostent;
+    char        *hostent_buf;  /* dynamically allocated */
+    unsigned     hostent_gencnt;
     PRNetAddr   *addr;
     PRUint32     expiration; /* measured in minutes since epoch */
 
-    PRBool HasResult() const { return addr_info || addr; }
+    PRBool HasResult() const { return hostent_buf || addr; }
 
 private:
     friend class nsHostResolver;
@@ -219,7 +220,7 @@ private:
     nsresult Init();
     nsresult IssueLookup(nsHostRecord *);
     PRBool   GetHostToLookup(nsHostRecord **);
-    void     OnLookupComplete(nsHostRecord *, nsresult, PRAddrInfo *);
+    void     OnLookupComplete(nsHostRecord *, nsresult);
 
     PR_STATIC_CALLBACK(void) ThreadFunc(void *);
 
diff --git a/toolkit/library/Makefile.in b/toolkit/library/Makefile.in
index 7b00f11..d30494c 100644
--- a/toolkit/library/Makefile.in
+++ b/toolkit/library/Makefile.in
@@ -253,3 +253,5 @@ endif
 ifneq (,$(filter layout-debug,$(MOZ_EXTENSIONS)))
 DEFINES += -DMOZ_ENABLE_EXTENSION_LAYOUT_DEBUG
 endif
+
+EXTRA_DSO_LDOPTS += -lobstcp
